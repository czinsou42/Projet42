# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    README                                             :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: czinsou <czinsou@student.42.fr>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2026/01/09 16:08:14 by czinsou           #+#    #+#              #
#    Updated: 2026/01/09 16:08:15 by czinsou          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

Voilà une version de README adaptée exactement à ta structure (`eat_mutex`, `get_bool`, `set_bool`, etc.).[1][2]

***

# Philosophers

Ce projet simule le problème des **philosophes mangeurs** (Dining Philosophers) en C, en utilisant des threads POSIX et des mutex pour gérer la concurrence. L’objectif est de coordonner plusieurs philosophes qui partagent des fourchettes, sans deadlocks, sans data races et en respectant des contraintes de temps.[3][1]

## 1. Concept du problème

Cinq philosophes (ou plus) sont assis autour d’une table, chacun avec une assiette de spaghetti, et une fourchette entre chaque paire de philosophes.[3]

Chaque philosophe :

- pense,
- prend deux fourchettes (gauche et droite),
- mange,
- repose les fourchettes,
- dort,
- puis recommence à penser.

Contraintes :

- un philosophe doit manger avant que `time_to_die` millisecondes ne s’écoulent depuis son dernier repas, sinon il **meurt** et la simulation s’arrête.[1]
- chaque prise de fourchette et chaque changement d’état est affiché avec un timestamp en ms depuis le début de la simulation.

## 2. Compilation et exécution

Compilation :

```bash
make
```

Exécution :

```bash
./philo number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]
```

Paramètres :

- `number_of_philosophers` : nombre de philosophes / fourchettes.  
- `time_to_die` (ms) : temps max sans manger avant la mort d’un philosophe.  
- `time_to_eat` (ms) : durée d’un repas.  
- `time_to_sleep` (ms) : durée du sommeil.  
- `number_of_times_each_philosopher_must_eat` (optionnel) : si fourni, la simulation s’arrête lorsque tous les philosophes ont mangé au moins ce nombre de fois.

Exemples :

```bash
./philo 4 410 200 200
./philo 5 800 200 200 5
```

## 3. Structures de données

### `t_fork`

```c
typedef struct s_fork
{
    t_mtx fork;
    int   fork_id;
}   t_fork;
```

- `fork` : mutex associé à la fourchette.  
- `fork_id` : index de la fourchette (debug, logs éventuels).

### `t_philo`

```c
typedef struct s_philo
{
    int       id;
    long      nbr_meals;
    bool      full;
    long      last_meals_time;
    t_fork    *first_fork;
    t_fork    *second_fork;
    int       have_first;
    int       have_second;
    pthread_t thread_id;
    t_table   *table;
}   t_philo;
```

- `id` : identifiant du philosophe (1..N).  
- `nbr_meals` : nombre de repas réalisés.  
- `full` : vrai si le philosophe a atteint la limite `nbr_limit_meals`.  
- `last_meals_time` : dernier instant (ms) où le philosophe a commencé à manger.  
- `first_fork` / `second_fork` : pointeurs vers les fourchettes que ce philosophe prend.  
- `have_first` / `have_second` : flags pour savoir quelles forks il possède actuellement (utile pour les unlock).  
- `thread_id` : thread POSIX du philosophe.  
- `table` : pointeur vers la structure globale.

### `t_table`

```c
typedef struct s_table
{
    long  philo_nbr;
    long  time_to_die;
    long  time_to_eat;
    long  time_to_sleep;
    long  nbr_limit_meals;
    long  start_simulation;
    bool  end_simulation;
    bool  all_threads_ready;
    t_mtx table_mutex;
    t_fork *forks;
    t_philo *philos;
}   t_table;
```

- `philo_nbr` : nombre de philosophes.  
- `time_to_die`, `time_to_eat`, `time_to_sleep` : paramètres de timing.  
- `nbr_limit_meals` : nombre de repas requis (ou -1 si pas de limite).  
- `start_simulation` : timestamp de départ de la simulation.  
- `end_simulation` : flag global indiquant que la simulation doit s’arrêter (mort ou tous pleins).  
- `all_threads_ready` : flag pour synchroniser le démarrage des philosophes avec le monitor.  
- `table_mutex` : mutex global pour protéger `end_simulation`, l’accès aux booléens, et l’affichage.[1]
- `forks` : tableau de `t_fork`.  
- `philos` : tableau de `t_philo`.

## 4. Fonctions principales

### Parsing et set‑up

- `int parse_arg(t_table *table, char **argv);`  
  Vérifie les arguments (format, chiffres uniquement, pas de valeur négative, pas de dépassement de `INT_MAX`, etc.) et remplit les champs de `t_table`.[1]

- `int data_init(t_table *table);`  
  - Alloue `table->philos` et `table->forks` via `safe_malloc`.  
  - Initialise `table_mutex` et les mutex de chaque `fork`.  
  - Initialise les flags (`end_simulation = false`, `all_threads_ready = false`).

- `void philo_init(t_table *table);`  
  - Initialise chaque philosophe : `id`, `nbr_meals`, `full`, `last_meals_time`, `eat_mutex`, etc.  
  - Associe les fourchettes avec `assign_forks`.  
  - `last_meals_time` est aligné sur `start_simulation`.[1]

- `void assign_forks(t_philo *philo, t_fork *forks, int pos);`  
  - Attribue à chaque philosophe ses deux fourchettes et définit un ordre (`first_fork` / `second_fork`) différent pour les pairs/impairs afin d’éviter les deadlocks.

### Routine des philosophes

- `void *philo_routine(void *arg);`  
  Thread exécuté par chaque philosophe :

  1. Décale légèrement le démarrage des philosophes pairs (pour limiter la contention sur les forks).  
  2. Boucle tant que `end_simulation` est faux :  
     - vérifie `end_simulation` sous `table_mutex`,  
     - `handle_forks(philo, LOCK)`,  
     - `philo_eat(philo)`,  
     - `handle_forks(philo, UNLOCK)`,  
     - `philo_sleep(philo)`,  
     - `philo_think(philo)`.

- `void handle_forks(t_philo *philo, t_mutex_action action);`  
  - `LOCK` :  
    - lock `first_fork`, print `"has taken a fork"`,  
    - lock `second_fork`, print `"has taken a fork"`,  
    - met à jour `have_first` / `have_second`.  
  - `UNLOCK` :  
    - libère les forks qu’il possède encore.  

- `void philo_eat(t_philo *philo);`  
  - `LOCK` sur `eat_mutex`.  
  - met à jour `last_meals_time` avec `gettime()` et incrémente `nbr_meals`.  
  - `UNLOCK` sur `eat_mutex`.  
  - affiche `"is eating"` puis dort `time_to_eat` via `my_usleep`.

- `void philo_think(t_philo *philo);`  
  Affiche `"is thinking"`.

### Monitor et contrôle de fin

- `void *routine(void *arg);`  
  Thread monitor :

  - tant que `end_simulation` est faux :  
    - appelle `check_philos(table)` pour détecter une mort,  
    - si `nbr_limit_meals > 0` et `all_full(table)` est vrai, met `end_simulation` à `true`,  
    - dort brièvement avec `my_usleep`.

- `void check_philos(t_table *table);`  
  Pour chaque philosophe :

  - lit l’heure avec `gettime()`,  
  - lock `eat_mutex` du philosophe, compare `now - last_meals_time` à `time_to_die`,  
  - si un philosophe est mort :  
    - lock `table_mutex`,  
    - `print_death(philo, "is died")`,  
    - met `end_simulation = true`,  
    - unlock mutex et retourne.  
  - met `full = true` si `nbr_meals >= nbr_limit_meals`.

- `bool all_full(t_table *table);`  
  Retourne `true` si tous les philosophes ont `full == true` (utilisé par le monitor pour arrêter la simulation quand la limite de repas est atteinte).

- `bool get_bool(t_mtx *mtx, bool *b);`  
  Lit un booléen (comme `end_simulation` ou `all_threads_ready`) de manière thread-safe sous protection de `mtx`.

- `void set_bool(t_mtx *mtx, bool *b, bool a);`  
  Écrit un booléen de manière thread-safe. Ces fonctions centralisent l’accès aux flags partagés.

### Utilitaires

- `long gettime(void);`  
  Retourne le temps actuel en millisecondes depuis l’époque (`gettimeofday`).

- `void my_usleep(long duration_ms, t_table *table);`  
  Attend `duration_ms` ms en petites tranches (`usleep(…)`) tout en vérifiant `end_simulation` pour pouvoir interrompre proprement les longues attentes si la simulation s’arrête.

- `void print_action(t_philo *philo, const char *action);`  
  Affiche une ligne : `<timestamp> <id> <action>`, protégée par `table_mutex` pour éviter que deux threads écrivent en même temps.

- `void print_death(t_philo *philo, const char *action);`  
  Affiche la mort d’un philosophe (souvent sans réutiliser `print_action` pour respecter la contrainte de ne rien afficher après un décès).

- `void *safe_malloc(size_t bytes);`  
  Wrapper autour de `malloc` qui gère les erreurs (message + retour `NULL`).

- `int safe_mutex(t_mtx *mutex, t_mutex_action action);`  
  Wrapper sur `pthread_mutex_*` avec gestion des codes d’erreur (`EINVAL`, `EDEADLK`, etc.).

- `int safe_thread(pthread_t *thread, void *(*f)(void *), void *data, t_threads_action action);`  
  Wrapper sur `pthread_create`, `pthread_join`, `pthread_detach` avec gestion des codes d’erreur.[9][8]

- `void destroy_all(t_table *table);`  
  Join des threads encore actifs, destruction des mutex (`eat_mutex`, mutex des forks, `table_mutex`) et `free` de tous les tableaux.[1]

***